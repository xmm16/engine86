
org 0x7E00

start:
    cli
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7C00

    mov ax, 0x4F02
    mov bx, 0x11F | 0x4000
    int 0x10

    mov ax, 0x4F01
    mov cx, 0x11F
    mov di, mode_info
    int 0x10
    
    

    mov eax, [mode_info + 0x28]
    mov [lfb_addr], eax

    movzx eax, word [mode_info + 0x10]
    mov [lfb_pitch], eax 

    lgdt [gdt_desc]

    mov eax, cr0
    or  eax, 1
    mov cr0, eax

    jmp CODE_SEL:pm_start

bits 32

pm_start:
    mov ax, DATA_SEL
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    mov esp, 0x90000

    mov esi, [lfb_addr]


    mov eax, cr0
    and eax, 0xFFFB 
    or  eax, 0x2 
    mov cr0, eax

    mov eax, cr4
    or  eax, 0x600
    mov cr4, eax






section .data

align 4
lfb_addr: dd 0
lfb_pitch: dd 0
zero: dd 0
NULL: dd 0
KEYS dd 128 dup(0)

mode_info: times 256 db 0

align 8
gdt:
    dq 0x0000000000000000
    dq 0x00CF9A000000FFFF
    dq 0x00CF92000000FFFF

gdt_desc:
    dw gdt_end - gdt - 1
    dd gdt
gdt_end:

CODE_SEL equ 0x08
DATA_SEL equ 0x10

section .text

pushasection .text

line:
; mov eax, 0 ; x1
; mov ebx, 0 ; y1
; mov ecx, 80 ; x2
; mov edx, 80 ; y2

mov edi, edx
sub edx, ebx
mov esi, ecx
sub esi, eax

; xmm0 = edi / esi
; xmm0 used to be edi, so replace accordingly
cvtsi2ss xmm0, edi
cvtsi2ss xmm1, esi
divss xmm0, xmm1
; slope in xmm0

mov esi, ebx
push ecx
mov ecx, edi
imul ecx, eax
sub esi, ecx ; integer y-intercept in esi
pop ecx

; rectangle should be from x1 -> x1 + 1
; y1 -> y1 + (y1 * slope + y-int)

push eax ; 20->16 x1
push ebx ; 16->12 y1
push ecx ; 12->8 x2
push edx ; 8->4 y2
push esi ; 0 y-int

mov esi, [lfb_addr]  
mov edx, [lfb_pitch]  

line_loop:
mov eax, [esp + 12] ; y1
mov ebx, [esp + 16] ; x1
cvtsi2ss xmm1, ebx
mulss xmm0, xmm1
cvttss2si ebx, xmm0
add ebx, [esp] ; now y2
mov [esp + 12], ebx

sub ebx, eax
imul eax, edx
add esi, eax

row_loop_line:
mov edi, esi
mov eax, [esp + 16]
cmp eax, [esp + 8]
jge line_done

mov ecx, eax
inc ecx
mov [esp + 16], ecx

sub ecx, eax
imul eax, 3
add edi, eax

pixel_loop_line:
mov byte [edi], 0x00
mov byte [edi + 1], 0x00
mov byte [edi + 2], 0xFF
add edi, 3
dec ecx
jnz pixel_loop_line

add esi, edx
dec ebx
jnz row_loop_line

line_done:
ret
